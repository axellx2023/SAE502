#!/usr/bin/env python3
"""
Interface Web Flask pour la gestion des configurations WireGuard
Permet de lister les fichiers .conf, les afficher, télécharger et générer des QR codes
"""
from flask import Flask, render_template, send_file, jsonify, request
import os
import glob
import qrcode
import io
from pathlib import Path
import re

app = Flask(__name__)
app.secret_key = os.environ.get('SECRET_KEY', '{{ webui_secret_key | default("change-me-in-production") }}')

# Chemins de configuration depuis variables d'environnement ou valeurs par défaut
CLIENTS_PATH = os.environ.get('CLIENTS_PATH', '{{ wireguard_clients_path }}')
QR_PATH = os.environ.get('QR_PATH', '{{ wireguard_qr_path }}')
ROLES_PATH = os.environ.get('ROLES_PATH', os.path.join(CLIENTS_PATH, ".roles.yml"))

ALLOWED_INTERNAL_ROLES = {"admin", "allowed"}

# Créer le dossier QR s'il n'existe pas
os.makedirs(QR_PATH, exist_ok=True)

def generate_qr_code(config_content):
    """Génère un QR code à partir du contenu de la configuration"""
    qr = qrcode.QRCode(
        version=1,
        error_correction=qrcode.constants.ERROR_CORRECT_L,
        box_size=10,
        border=4,
    )
    qr.add_data(config_content)
    qr.make(fit=True)
    
    img = qr.make_image(fill_color="black", back_color="white")
    return img

def load_roles():
    """Charge les rôles depuis le fichier YAML sans dépendance externe."""
    roles = {}

    if not os.path.exists(ROLES_PATH):
        return roles

    with open(ROLES_PATH, "r") as f:
        in_users_block = False
        for raw_line in f:
            line = raw_line.strip()
            if not line or line.startswith("#"):
                continue

            if line == "users:":
                in_users_block = True
                continue

            if in_users_block:
                # Attend un format simple: "username: role"
                match = re.match(r"^([^:]+):\s*(.+)$", line)
                if match:
                    username = match.group(1).strip()
                    role = match.group(2).strip()
                    roles[username] = role
                else:
                    # Si on sort du bloc, arrêter la lecture du mapping.
                    if not raw_line.startswith((" ", "\t")):
                        in_users_block = False

    return roles

def get_authenticated_username():
    auth = request.authorization
    if auth and auth.username:
        return auth.username

    header_user = request.headers.get("X-Remote-User")
    if header_user:
        return header_user

    return None

def has_internal_access():
    username = get_authenticated_username()
    if not username:
        return False, None, None

    roles = load_roles()
    role = roles.get(username)
    return role in ALLOWED_INTERNAL_ROLES, username, role

@app.route('/')
def index():
    """Page d'accueil listant tous les fichiers .conf"""
    clients = []
    
    # Récupérer tous les fichiers .conf
    conf_files = glob.glob(os.path.join(CLIENTS_PATH, "*.conf"))
    
    for conf_file in conf_files:
        username = os.path.basename(conf_file).replace('.conf', '')
        qr_file = os.path.join(QR_PATH, f"{username}.png")
        
        clients.append({
            'name': username,
            'conf_exists': os.path.exists(conf_file),
            'qr_exists': os.path.exists(qr_file)
        })
    
    return render_template('index.html', clients=clients)

@app.route('/interne')
def internal_page():
    """Page interne avec objectifs et compte rendu."""
    is_allowed, username, role = has_internal_access()
    if not is_allowed:
        return render_template(
            'access_denied.html',
            username=username,
            user_role=role,
        ), 403

    return render_template('internal.html', username=username, user_role=role)

@app.route('/client/<username>')
def view_client(username):
    """Afficher une configuration individuelle"""
    conf_file = os.path.join(CLIENTS_PATH, f"{username}.conf")
    
    if not os.path.exists(conf_file):
        return jsonify({'error': 'Fichier non trouvé'}), 404
    
    # Lire le contenu de la configuration
    with open(conf_file, 'r') as f:
        config_content = f.read()
    
    # Générer le QR code si nécessaire
    qr_file = os.path.join(QR_PATH, f"{username}.png")
    qr_exists = os.path.exists(qr_file)
    
    return render_template('client.html', 
                         username=username, 
                         config_content=config_content,
                         qr_exists=qr_exists)

@app.route('/download/<username>')
def download_conf(username):
    """Télécharger le fichier de configuration d'un utilisateur"""
    conf_file = os.path.join(CLIENTS_PATH, f"{username}.conf")
    
    if os.path.exists(conf_file):
        return send_file(conf_file, as_attachment=True, download_name=f"{username}.conf")
    else:
        return jsonify({'error': 'Fichier non trouvé'}), 404

@app.route('/qr/<username>')
def show_qr(username):
    """Afficher ou générer le QR code d'un utilisateur"""
    conf_file = os.path.join(CLIENTS_PATH, f"{username}.conf")
    qr_file = os.path.join(QR_PATH, f"{username}.png")
    
    if not os.path.exists(conf_file):
        return jsonify({'error': 'Configuration non trouvée'}), 404
    
    # Si le QR code existe, le renvoyer
    if os.path.exists(qr_file):
        return send_file(qr_file, mimetype='image/png')
    
    # Sinon, générer le QR code à la volée
    with open(conf_file, 'r') as f:
        config_content = f.read()
    
    img = generate_qr_code(config_content)
    
    # Sauvegarder pour la prochaine fois
    img.save(qr_file)
    
    # Retourner l'image
    img_io = io.BytesIO()
    img.save(img_io, 'PNG')
    img_io.seek(0)
    return send_file(img_io, mimetype='image/png')

@app.route('/api/clients')
def api_clients():
    """API JSON listant tous les clients"""
    clients = []
    conf_files = glob.glob(os.path.join(CLIENTS_PATH, "*.conf"))
    
    for conf_file in conf_files:
        username = os.path.basename(conf_file).replace('.conf', '')
        clients.append({'name': username})
    
    return jsonify(clients)

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=False)
